<!--

commands

-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script type="text/javascript" src="three.js"></script>
    <script type="text/javascript" src="orbit.js"></script>
    <script type="text/javascript" src="poodle.js"></script>
    <title>Poodle</title>
  </head>
  <body>
    <script>
      console.clear()
      var camera, controls, scene, renderer;
      init();
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate();
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xcccccc );
        scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 400, 200, 0 );
        // controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        // world
        var geometry = new THREE.CylinderBufferGeometry( 0, 10, 30, 4, 1 );
        var material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
        for ( var i = 0; i < 500; i ++ ) {
          var mesh = new THREE.Mesh( geometry, material );
          mesh.position.x = Math.random() * 1600 - 800;
          mesh.position.y = 0;
          mesh.position.z = Math.random() * 1600 - 800;
          mesh.updateMatrix();
          mesh.matrixAutoUpdate = false;
          scene.add( mesh );
        }
        // lights
        var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 1, 1, 1 );
        scene.add( light );
        var light = new THREE.DirectionalLight( 0x002288 );
        light.position.set( - 1, - 1, - 1 );
        scene.add( light );
        var light = new THREE.AmbientLight( 0x222222 );
        scene.add( light );

        //create a blue LineBasicMaterial
        var material = new THREE.LineBasicMaterial( { color: 0xffffff } );

        var line1 = new THREE.Line( new THREE.BoxGeometry( 30, 30, 30 ), material );
        var line2 = new THREE.Line( new THREE.BoxGeometry( 20, 20, 20 ), material );

        scene.add( line1 );
        scene.add( line2 );


        //
        window.addEventListener( 'resize', onWindowResize, false );
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }
      function animate() {
        requestAnimationFrame( animate );
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
        render();
      }
      function render() {
        renderer.render( scene, camera );
      }
    </script>
    <style>
      * { margin:0;padding:0;border:0;outline:0; position:fixed }
      body { overflow: hidden; background:#eee }
      canvas { border-radius: 3px; transition: top 250ms, left 250ms; image-rendering: pixelated; image-rendering: optimizeSpeed; }
    </style>
  </body>
</html>
